<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Tetris Archive | Study Master</title>
    <style>
        :root {
            --primary: #89b4fa; --dark: #050508; --white: #cdd6f4;
            --orange: #fab387; --accent: #f38ba8; --surface: #11111b;
            --gold: #f9e2af; --border: #313244;
        }

        body {
            background-color: var(--dark); font-family: 'Arial Black', sans-serif;
            margin: 0; color: var(--white); overflow: hidden;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            height: 100vh;
            background: radial-gradient(circle at center, #11111b 0%, #050508 100%);
        }

        header { text-align: center; margin-bottom: 40px; }
        h1 { font-size: 4rem; margin: 0; color: var(--gold); letter-spacing: -3px; }

        /* Ultra Curved Grid */
        #library-menu { 
            display: grid; grid-template-columns: repeat(3, 1fr); 
            gap: 25px; width: 95%; max-width: 1100px;
        }

        .lib-card {
            background: var(--surface); border: 2px solid var(--border); 
            border-radius: 50px; padding: 40px; cursor: pointer;
            transition: 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            text-align: center; display: flex; flex-direction: column;
            justify-content: space-between; min-height: 320px;
        }

        .lib-card:hover { 
            transform: scale(1.05); border-color: var(--primary);
            box-shadow: 0 20px 60px rgba(137, 180, 250, 0.15);
        }

        .lib-card h2 { font-size: 2.2rem; margin: 0; color: var(--primary); }
        .lib-card p { font-family: 'Arial', sans-serif; font-size: 1rem; opacity: 0.6; line-height: 1.5; }

        .btn-start { 
            background: var(--primary); color: var(--dark); padding: 15px; 
            border-radius: 40px; font-size: 1.1rem; font-weight: bold; border: none;
        }

        /* Game UI */
        #game-view { display: none; gap: 40px; align-items: center; animation: zoomIn 0.4s ease; }
        canvas { border: 10px solid var(--surface); border-radius: 45px; background: #000; box-shadow: 0 0 80px rgba(0,0,0,0.8); }
        
        .stat-panel { 
            background: var(--surface); padding: 35px; border-radius: 50px; 
            width: 260px; border: 2px solid var(--border); text-align: center;
        }
        
        .score-box { font-size: 3.5rem; color: var(--gold); margin: 10px 0; }
        .control-hint { font-size: 0.7rem; opacity: 0.5; margin-top: 20px; line-height: 2; }
        
        .exit-btn { 
            background: var(--accent); color: var(--dark); border: none; 
            padding: 15px; border-radius: 40px; font-family: inherit; 
            cursor: pointer; width: 100%; margin-top: 25px;
        }

        @keyframes zoomIn { from { opacity: 0; transform: scale(0.9); } to { opacity: 1; transform: scale(1); } }
    </style>
</head>
<body>

    <header id="lib-header">
        <h1>TETRIS ARCHIVE</h1>
        <p style="color: var(--primary); opacity: 0.8; letter-spacing: 4px; font-size: 0.8rem;">SELECT YOUR MODE</p>
    </header>

    <div id="library-menu">
        <div class="lib-card" onclick="startTetris('easy')">
            <h2>Easy Mode</h2>
            <p>The original I-piece challenge. Straight lines only for maximum efficiency and high scores.</p>
            <button class="btn-start">PLAY EASY</button>
        </div>

        <div class="lib-card" onclick="startTetris('classic')">
            <h2>Classic</h2>
            <p>The authentic 7-shape rotation. Perfectly balanced gravity for a standard competitive experience.</p>
            <button class="btn-start">PLAY CLASSIC</button>
        </div>

        <div class="lib-card" onclick="startTetris('hard')">
            <h2>Hardcore</h2>
            <p>Level 15 starting speed. Instant piece locking. One mistake ends the run. For the elite only.</p>
            <button class="btn-start" style="background:var(--accent)">PLAY HARD</button>
        </div>
    </div>

    <div id="game-view">
        <div class="stat-panel">
            <div style="font-size: 0.8rem; opacity: 0.6;">SCORE</div>
            <div class="score-box" id="score">0000</div>
            <div style="font-size: 0.7rem; color: var(--primary);">+10 PER PLACEMENT</div>
            <div class="control-hint">
                <b style="color:var(--gold)">ARROWS</b> TO MOVE/ROT<br>
                <b style="color:var(--gold)">SPACE</b> TO HARD DROP
            </div>
            <button class="exit-btn" onclick="location.reload()">BACK TO MENU</button>
        </div>
        <canvas id="tetris-canvas" width="240" height="480"></canvas>
    </div>

    <script>
        const canvas = document.getElementById('tetris-canvas');
        const ctx = canvas.getContext('2d');
        const scoreElement = document.getElementById('score');
        ctx.scale(24, 24);

        let gameMode = 'classic', dropCounter = 0, dropInterval = 1000, lastTime = 0, score = 0;
        const colors = [null, '#89b4fa', '#f38ba8', '#a6e3a1', '#fab387', '#94e2d5', '#cba6f7', '#f9e2af'];
        const pieces = 'ILJOTSZ';

        function createPiece(type) {
            if (type === 'I') return [[0,1,0,0],[0,1,0,0],[0,1,0,0],[0,1,0,0]];
            if (type === 'L') return [[0,2,0],[0,2,0],[0,2,2]];
            if (type === 'J') return [[0,3,0],[0,3,0],[3,3,0]];
            if (type === 'O') return [[4,4],[4,4]];
            if (type === 'T') return [[0,5,0],[5,5,5],[0,0,0]];
            if (type === 'S') return [[0,6,6],[6,6,0],[0,0,0]];
            if (type === 'Z') return [[7,7,0],[0,7,7],[0,0,0]];
        }

        function draw() {
            ctx.fillStyle = '#000'; ctx.fillRect(0, 0, canvas.width, canvas.height);
            drawMatrix(arena, {x: 0, y: 0}); drawMatrix(player.matrix, player.pos);
        }

        function drawMatrix(matrix, offset) {
            matrix.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value !== 0) {
                        ctx.fillStyle = colors[value];
                        ctx.fillRect(x + offset.x, y + offset.y, 1, 1);
                    }
                });
            });
        }

        function arenaSweep() {
            let rowCount = 1;
            outer: for (let y = arena.length - 1; y > 0; --y) {
                for (let x = 0; x < arena[y].length; ++x) { if (arena[y][x] === 0) continue outer; }
                const row = arena.splice(y, 1)[0].fill(0);
                arena.unshift(row); ++y;
                score += rowCount * 100; rowCount *= 2;
            }
            updateScoreUI();
        }

        function collide(arena, player) {
            const [m, o] = [player.matrix, player.pos];
            for (let y = 0; y < m.length; ++y) {
                for (let x = 0; x < m[y].length; ++x) {
                    if (m[y][x] !== 0 && (arena[y + o.y] && arena[y + o.y][x + o.x]) !== 0) return true;
                }
            }
            return false;
        }

        function merge(arena, player) {
            player.matrix.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value !== 0) arena[y + player.pos.y][x + player.pos.x] = value;
                });
            });
            score += 10; updateScoreUI();
        }

        function updateScoreUI() { scoreElement.innerText = score.toString().padStart(4, '0'); }

        function playerDrop() {
            player.pos.y++;
            if (collide(arena, player)) { player.pos.y--; merge(arena, player); playerReset(); arenaSweep(); }
            dropCounter = 0;
        }

        function rotate(matrix) {
            for (let y = 0; y < matrix.length; ++y) {
                for (let x = 0; x < y; ++x) { [matrix[x][y], matrix[y][x]] = [matrix[y][x], matrix[x][y]]; }
            }
            matrix.forEach(row => row.reverse());
        }

        function playerRotate() {
            const pos = player.pos.x; let offset = 1; rotate(player.matrix);
            while (collide(arena, player)) {
                player.pos.x += offset;
                offset = -(offset + (offset > 0 ? 1 : -1));
                if (offset > player.matrix[0].length) { rotate(player.matrix); player.pos.x = pos; return; }
            }
        }

        function playerReset() {
            const type = gameMode === 'easy' ? 'I' : pieces[pieces.length * Math.random() | 0];
            player.matrix = createPiece(type);
            player.pos.y = 0; player.pos.x = (arena[0].length / 2 | 0) - (player.matrix[0].length / 2 | 0);
            if (collide(arena, player)) { arena.forEach(row => row.fill(0)); score = 0; updateScoreUI(); }
        }

        function update(time = 0) {
            const deltaTime = time - lastTime; lastTime = time;
            dropCounter += deltaTime; if (dropCounter > dropInterval) playerDrop();
            draw(); requestAnimationFrame(update);
        }

        const arena = Array.from({length: 20}, () => Array(10).fill(0));
        const player = { pos: {x: 0, y: 0}, matrix: null };

        document.addEventListener('keydown', e => {
            if (e.keyCode === 37) { player.pos.x--; if(collide(arena,player)) player.pos.x++; }
            if (e.keyCode === 39) { player.pos.x++; if(collide(arena,player)) player.pos.x--; }
            if (e.keyCode === 40) playerDrop();
            if (e.keyCode === 38) playerRotate();
            if (e.keyCode === 32) { while(!collide(arena, player)) { player.pos.y++; } player.pos.y--; merge(arena, player); playerReset(); arenaSweep(); }
        });

        function startTetris(mode) {
            gameMode = mode;
            document.getElementById('lib-header').style.display = 'none';
            document.getElementById('library-menu').style.display = 'none';
            document.getElementById('game-view').style.display = 'flex';
            dropInterval = mode === 'hard' ? 120 : 800;
            playerReset(); update();
        }
    </script>
</body>
</html>